/*
https://www.nowcoder.com/questionTerminal/12cbdcdf5d1e4059b6ddd420de6342b6

牛客网 2016 美团 拜访



题目描述
现在有一个城市销售经理，需要从公司出发，去拜访市内的商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他只能在左右中选择一个方向，在上下中选择一个方向，现在问他有多少种方案到达商家地址。

给定一个地图map及它的长宽n和m，其中1代表经理位置，2代表商家位置，-1代表不能经过的地区，0代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于10。


想说的是题目描述有点模糊，通过测试才发现，“他只能在左右中选择一个方向，在上下中选择一个方向”应该理解为：左右中只能选一个方向，若选择左只能一直向左走。上下中只能选择一个方向，若选择下只能一直向下。
解题思路：
1.首先找到1和2的位置，这里要注意一点，从1走到2与从2走到1所得的路径数相同，即以1为起点或以2为起点是等价的。所以我做的处理是，统一从行坐标小的位置走到行坐标大的位置，即向下走。
2.1和2的相对位置可以归纳如下：
（1）两者位于主对角线上
（2）两者位于副对角线上
（3）两者位置重合或处于同一行或同一列（该特殊情形可以合并到（1）（2）中）



测试样例：
[[0,1,0],[2,0,0]],2,3
返回：2
     * input
     * [0],[1],[2]],3,1
     * [[0],[0],[2],[1]],4,1
     * [[0,0,0,0,0],[0,0,0,0,0],[0,1,0,0,2]],3,5
     * output
     * 1
     * 1
     * 1

*/



import java.util.*;

public class Visit {
    public int countPath(int[][] map, int n, int m) {
        int i,j;
        int x0=0,x1=0,y0=0,y1=0;
        for(i=0;i<map.length;i++){
        	for(j = 0 ;j<map[0].length;j++){
        		if(map[i][j]==1){
        			x0=i;
        			y0=j;
        		}
        		if(map[i][j]==2){
        			x1=i;
        			y1=j;
        		}
        	}
        }
        if(x0==x1&&y0==y1){
        	return 1;
        }
        //这里一定要保证起点在上方，终点在下方
        //x0保证最小
        if(x0>x1){
        	
        	x0=x0^x1^(x1=x0);
        	y0=y0^y1^(y1=y0);
        }
        if(x0==x1){
        	
        }

        
        //动态规划，核心算法
        int dp[][] = new int[map.length][map[0].length];
        if(y0<y1){// 两点处在主对角线上 起点在左上方，终点在右下方。只能往右往下两个方向
        	dp[x0][y0] = 1;
        	//先初始化右和下两个方向为1
        	for (i = x0+1; i<=x1; i++) {
        		dp[i][y0]=map[i][y0]==-1 ? 0:dp[i-1][y0];
        	}
        	for (i = y0+1; i<=y1; i++) {
        		dp[x0][i]=map[x0][i]==-1 ? 0:dp[x0][i-1];
        	}
        	for (i = x0+1; i<=x1; i++) {
        		for(j = y0+1; j<=y1; j++){
        			dp[i][j]=map[i][j]==-1?0:dp[i-1][j]+dp[i][j-1];
        		}
        	}
        	
        	
        }else{// 两点处在主对角线上 起点在右上方，终点在左下方
        	dp[x0][y0] = 1;
        	//先初始化左和下两个方向为1
        	for (i = x0+1; i<=x1; i++) {
        		dp[i][y0]=map[i][y0]==-1 ? 0:dp[i-1][y0];
        	}
        	for (i = y0-1; i>=y1; i--) {
        		dp[x0][i]=map[x0][i]==-1 ? 0:dp[x0][i+1];
        	}
        	for (i = x0+1; i<=x1; i++) {
        		for(j = y0-1; j>=y1; j--){
        			dp[i][j]=map[i][j]==-1?0:dp[i-1][j]+dp[i][j+1];
        		}
        	}
        }
        return dp[x1][y1];
    }
}